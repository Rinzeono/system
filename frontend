import React, { useState, useEffect, useRef } from "react";
import { LineChart, Line, XAxis, YAxis, CartesianGrid, Tooltip, Legend, ResponsiveContainer } from "recharts";
import Editor from '@monaco-editor/react';

const MAX_POINTS = 30;

function App() {
  const [user, setUser] = useState(null); // "taro" or "jiro"
  const [taroEditorText, setTaroEditorText] = useState("");
  const [jiroEditorText, setJiroEditorText] = useState("");
  const [chartData, setChartData] = useState([]);
  const [isRecording, setIsRecording] = useState(false);
  const [transcribedText, setTranscribedText] = useState("");
  const ws = useRef(null);

  // 録音用
  const mediaRecorderRef = useRef(null);
  const audioChunksRef = useRef([]);
  const audioStreamRef = useRef(null);

  // グラフを0.1秒ごとに0.1ずつ減少させて滑らかに流す
  useEffect(() => {
    const interval = setInterval(() => {
      setChartData(prev => {
        if (prev.length === 0) return prev;
        // lastの初期値を必ず全プロパティ持つ形に
        const last = prev[prev.length - 1] ?? { taro_input: 0, taro_speech: 0, jiro_input: 0, jiro_speech: 0, time: new Date().toLocaleTimeString() };
        const decayed = {
          ...last,
          taro_input: Math.max(0, last.taro_input - 0.1),
          taro_speech: Math.max(0, last.taro_speech - 0.1),
          jiro_input: Math.max(0, last.jiro_input - 0.1),
          jiro_speech: Math.max(0, last.jiro_speech - 0.1),
          time: new Date().toLocaleTimeString(),
        };
        const newArr = [...prev, decayed].slice(-MAX_POINTS);
        return newArr;
      });
    }, 100); // 0.1秒ごと
    return () => clearInterval(interval);
  }, []); // ←依存配列は[]でOK

  // WebSocketで新しいデータが来たときもlastの初期値を必ず全プロパティ持つ形に
  useEffect(() => {
    ws.current = new window.WebSocket("ws://localhost:8001/ws/data");
    ws.current.onopen = () => ws.current.send("init");
    ws.current.onmessage = (event) => {
      const logs = JSON.parse(event.data);
      setChartData(prev => {
        const taroArr = Array.isArray(logs.taro_input) ? logs.taro_input : [];
        const taroSpeechArr = Array.isArray(logs.taro_speech) ? logs.taro_speech : [];
        const jiroArr = Array.isArray(logs.jiro_input) ? logs.jiro_input : [];
        const jiroSpeechArr = Array.isArray(logs.jiro_speech) ? logs.jiro_speech : [];
        const taro_input = taroArr.length > 0 ? taroArr[taroArr.length - 1] : 0;
        const taro_speech = taroSpeechArr.length > 0 ? (taroSpeechArr[taroSpeechArr.length - 1]?.length || 0) : 0;
        const jiro_input = jiroArr.length > 0 ? jiroArr[jiroArr.length - 1] : 0;
        const jiro_speech = jiroSpeechArr.length > 0 ? (jiroSpeechArr[jiroSpeechArr.length - 1]?.length || 0) : 0;

        // lastの初期値を必ず全プロパティ持つ形に
        const last = prev.length > 0
          ? prev[prev.length - 1]
          : { taro_input: 0, taro_speech: 0, jiro_input: 0, jiro_speech: 0, time: new Date().toLocaleTimeString() };

        let next;
        if (user === "taro") {
          next = {
            time: new Date().toLocaleTimeString(),
            taro_input: last.taro_input,
            taro_speech: taro_speech,
            jiro_input: jiro_input,
            jiro_speech: jiro_speech,
          };
        } else if (user === "jiro") {
          next = {
            time: new Date().toLocaleTimeString(),
            taro_input: taro_input,
            taro_speech: taro_speech,
            jiro_input: last.jiro_input,
            jiro_speech: jiro_speech,
          };
        }

        // 新しいデータが前回と同じなら追加しない
        if (
          prev.length > 0 &&
          prev[prev.length - 1].taro_input === next.taro_input &&
          prev[prev.length - 1].taro_speech === next.taro_speech &&
          prev[prev.length - 1].jiro_input === next.jiro_input &&
          prev[prev.length - 1].jiro_speech === next.jiro_speech
        ) {
          return prev;
        }
        return [...prev.slice(-MAX_POINTS + 1), next];
      });
      // ここで最新の文字起こし結果を反映
      if (logs.transcript !== undefined) {
        setTranscribedText(logs.transcript);
      }
    };
    return () => ws.current && ws.current.close();
  }, [user]);

  // エディタの内容をユーザーごとに管理
  const handleEditorChange = (value) => {
    if (user === "taro") {
      setTaroEditorText(value);
      setChartData(prev => {
        // lastの初期値を必ず全プロパティ持つ形に
        const last = prev.length > 0
          ? prev[prev.length - 1]
          : { taro_input: 0, taro_speech: 0, jiro_input: 0, jiro_speech: 0, time: new Date().toLocaleTimeString() };
        return [
          ...prev.slice(-MAX_POINTS + 1),
          {
            ...last,
            time: new Date().toLocaleTimeString(),
            taro_input: value ? value.length : 0,
          }
        ];
      });
      sendInput("taro", value ? value.length : 0);
    } else if (user === "jiro") {
      setJiroEditorText(value);
      setChartData(prev => {
        // lastの初期値を必ず全プロパティ持つ形に
        const last = prev.length > 0
          ? prev[prev.length - 1]
          : { taro_input: 0, taro_speech: 0, jiro_input: 0, jiro_speech: 0, time: new Date().toLocaleTimeString() };
        return [
          ...prev.slice(-MAX_POINTS + 1),
          {
            ...last,
            time: new Date().toLocaleTimeString(),
            jiro_input: value ? value.length : 0,
          }
        ];
      });
      sendInput("jiro", value ? value.length : 0);
    }
  };

  // 録音開始
  const startRecording = async () => {
    try {
      const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
      audioStreamRef.current = stream;
      mediaRecorderRef.current = new window.MediaRecorder(stream);
      audioChunksRef.current = [];
      mediaRecorderRef.current.ondataavailable = async (event) => {
        if (event.data.size > 0) {
          // チャンクごとにFastAPIサーバーへ送信
          const audioBlob = new Blob([event.data], { type: "audio/webm" });
          const formData = new FormData();
          formData.append("file", audioBlob, "chunk.webm");
          try {
            await fetch(`http://localhost:8001/stream/audio?speaker=${user}`, {
              method: "POST",
              body: formData,
            });
          } catch (e) {
            alert("音声送信に失敗しました: " + e.message);
          }
        }
      };
      mediaRecorderRef.current.start(500); // 0.5秒ごとにチャンク化
      setIsRecording(true);
    } catch (error) {
      alert("マイクが利用できません: " + error.message);
    }
  };

  // 録音停止
  const stopRecording = () => {
    if (mediaRecorderRef.current) {
      mediaRecorderRef.current.stop();
      audioStreamRef.current?.getTracks().forEach(track => track.stop());
      setIsRecording(false);
    }
  };

  // 入力値をサーバーに送信する関数を追加
  const sendInput = (speaker, length) => {
    fetch(`http://localhost:8001/stream/input?speaker=${speaker}&length=${length}`, {
      method: "POST",
    }).catch(() => {});
  };

  // ユーザー選択画面
  if (!user) {
    return (
      <div style={{
        minHeight: "100vh",
        background: "linear-gradient(135deg, #181c20 60%, #23272f 100%)",
        color: "#fff",
        display: "flex",
        flexDirection: "column",
        alignItems: "center",
        justifyContent: "center"
      }}>
        <h1 style={{ fontSize: 32, color: "#00eaff", marginBottom: 32 }}>ユーザーを選択してください</h1>
        <div style={{ display: "flex", gap: 40 }}>
          <button
            style={{
              padding: "20px 48px",
              fontSize: 24,
              background: "linear-gradient(90deg, #00eaff 60%, #23272f 100%)",
              color: "#181c20",
              border: "none",
              borderRadius: 12,
              fontWeight: "bold",
              cursor: "pointer",
              boxShadow: "0 2px 8px #000a",
              marginRight: 16
            }}
            onClick={() => setUser("taro")}
          >
            太郎で始める
          </button>
          <button
            style={{
              padding: "20px 48px",
              fontSize: 24,
              background: "linear-gradient(90deg, #ffb300 60%, #23272f 100%)",
              color: "#181c20",
              border: "none",
              borderRadius: 12,
              fontWeight: "bold",
              cursor: "pointer",
              boxShadow: "0 2px 8px #000a"
            }}
            onClick={() => setUser("jiro")}
          >
            次郎で始める
          </button>
        </div>
      </div>
    );
  }

  // メイン画面
  return (
    <div className="App">
      <header className="App-header">
        <h1>リアルタイム会話ダッシュボード</h1>
        <p style={{ color: "#aaa", fontSize: 16 }}>
          {user === "taro" ? "太郎" : "次郎"}として操作中／グラフは全員リアルタイム同期
        </p>
        <div style={{ margin: "16px 0" }}>
          {!isRecording ? (
            <button onClick={startRecording}>録音開始</button>
          ) : (
            <button onClick={stopRecording}>録音停止</button>
          )}
        </div>
      </header>
      <div style={{
        display: "flex",
        justifyContent: "center",
        alignItems: "flex-start",
        gap: 32,
        maxWidth: 1600,
        margin: "0 auto",
      }}>
        {/* エディタ */}
        <div style={{
          background: "#23272f",
          borderRadius: 12,
          padding: 24,
          boxShadow: "0 2px 16px #000a",
          minWidth: 400,
          maxWidth: 600,
          flex: "0 0 500px",
        }}>
          <h3 style={{ color: user === "taro" ? "#00eaff" : "#ffb300" }}>
            Monacoエディタ（{user === "taro" ? "太郎" : "次郎"}）
          </h3>
          <Editor
            height="40vh"
            defaultLanguage="python"
            value={user === "taro" ? taroEditorText : jiroEditorText}
            onChange={handleEditorChange}
            theme="vs-dark"
            options={{
              fontSize: 16,
              minimap: { enabled: false },
              fontFamily: "Consolas, 'Segoe UI', monospace",
              background: "#181c20",
            }}
          />
          <div style={{ color: "#aaa", marginTop: 8 }}>
            文字数: {(user === "taro" ? taroEditorText : jiroEditorText).length}
          </div>
        </div>

        {/* グラフ（太郎） */}
        <div style={{
          background: "#181c20",
          borderRadius: 12,
          padding: 24,
          maxWidth: 600,
          minWidth: 400,
          flex: "1 1 600px",
          boxShadow: "0 2px 16px #000a",
        }}>
          <h2 style={{ color: "#00eaff", marginBottom: 16 }}>太郎の操作量・発話量グラフ</h2>
          <ResponsiveContainer width="100%" height={400}>
            <LineChart data={chartData}>
              <CartesianGrid stroke="#333" strokeDasharray="3 3" />
              <XAxis dataKey="time" stroke="#aaa" />
              <YAxis stroke="#aaa" interval={0} domain={[0, 'auto']} tickCount={10} />
              <Tooltip contentStyle={{ background: "#23272f", border: "none", color: "#fff" }} />
              <Legend />
              <Line type="monotone" dataKey="taro_input" stroke="#00eaff" name="太郎 操作量" dot={false} strokeWidth={3} />
              <Line type="monotone" dataKey="taro_speech" stroke="#00ff99" name="太郎 発話量" dot={false} strokeWidth={2} />
            </LineChart>
          </ResponsiveContainer>
        </div>
        {/* グラフ（次郎） */}
        <div style={{
          background: "#181c20",
          borderRadius: 12,
          padding: 24,
          maxWidth: 600,
          minWidth: 400,
          flex: "1 1 600px",
          boxShadow: "0 2px 16px #000a",
        }}>
          <h2 style={{ color: "#ffb300", marginBottom: 16 }}>次郎の操作量・発話量グラフ</h2>
          <ResponsiveContainer width="100%" height={400}>
            <LineChart data={chartData}>
              <CartesianGrid stroke="#333" strokeDasharray="3 3" />
              <XAxis dataKey="time" stroke="#aaa" />
              <YAxis stroke="#aaa" interval={0} domain={[0, 'auto']} tickCount={10} />
              <Tooltip contentStyle={{ background: "#23272f", border: "none", color: "#fff" }} />
              <Legend />
              <Line type="monotone" dataKey="jiro_input" stroke="#ffb300" name="次郎 操作量" dot={false} strokeWidth={3} />
              <Line type="monotone" dataKey="jiro_speech" stroke="#ff4081" name="次郎 発話量" dot={false} strokeWidth={2} strokeDasharray="2 2" />
            </LineChart>
          </ResponsiveContainer>
        </div>
      </div>
      <div style={{ margin: "32px auto", maxWidth: 800 }}>
        <h3>文字起こし結果:</h3>
        <pre
          style={{
            background: "#23272f",
            color: "#fff",
            padding: 16,
            borderRadius: 8,
            minHeight: 80,
          }}
        >
          {transcribedText}
        </pre>
      </div>
    </div>
  );
}

export default App;
